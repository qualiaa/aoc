#!/usr/bin/env bqn

StrToInt â† +âŸœ(10âŠ¸Ã—)Â´ âˆ˜ âŒ½ âˆ˜ -âŸœ'0'
numeric â† '0' + â†•10

ParseNumberList â† {
  StrToIntÂ¨ 0âŠ¸<âŸœ(â‰ Â¨)âŠ¸/ 1â†“(1âŠ¸(+`)âˆ˜Â¬âŠ¸Ã— âˆŠâŸœnumeric)âŠ¸âŠ” ğ•©
}

ParseGroup â† {
  lines â† 1 â†“ ğ•©  # Drop label line
  n â† âŠ‘ âŠâŸœâŸ¨âŸ¨âŸ©âŸ© lines
  âŸ¨âˆ§ (1â€¿0â€¿2âŠ¸âŠË˜) > ParseNumberListÂ¨ nâ†‘lines ,  (n+1) â†“linesâŸ©
}

ParseGroups â† {gâ€¿âŸ¨âŸ©: â‹ˆg; gâ€¿x: (â‹ˆg) âˆ¾ ParseGroups x} âˆ˜ ParseGroup

Lookup â† {
  LookupOne â† {
    srcâ€¿destâ€¿size â† ğ•©
    (0âŠ¸â‰¤âˆ§<âŸœsize)âˆ˜(-âŸœsrc)â—¶âŸ¨âŠ¢, destâŠ¸+ -âŸœsrcâŸ© âŠ‘ ğ•¨
  }
  ğ•¨ LookupOneË˜  (0âŒˆË˜ ((âŠË˜ ğ•©) â‹ ğ•¨) - 1) âŠ ğ•©
}

input â† â€¢FLines "/dev/stdin"

seeds â† ParseNumberList âŠ‘ input
maps â† ParseGroups 2â†“ input

â€¢Show âŒŠÂ´ seeds LookupËœÂ´ (âŒ½maps)
# Part B solution is to compose the maps into one and identify crossing
# points... Not sure if I can be bothered.


